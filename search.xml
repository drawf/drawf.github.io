<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[C语言基础知识补习①]]></title>
      <url>http://51erwa.com/2017/02/18/c-basics-record/</url>
      <content type="html"><![CDATA[<h3 id="放在前边"><a href="#放在前边" class="headerlink" title="放在前边"></a>放在前边</h3><blockquote>
<p>注：本篇是C语言的基础知识补习的第一篇，共两篇，需要读者有一定的编程经验。</p>
</blockquote>
<p><a href="https://github.com/drawf/demo.retrofit" target="_blank" rel="external">demo.c传送门</a></p>
<h3 id="C-C-的开发工具"><a href="#C-C-的开发工具" class="headerlink" title="C/C++的开发工具"></a>C/C++的开发工具</h3><p>链接: <a href="https://pan.baidu.com/s/1eSh1Uuu" target="_blank" rel="external">https://pan.baidu.com/s/1eSh1Uuu</a> 密码: sp3t</p>
<p>CLion for Mac 2016.3 版本，CMake workflow、Modern C and C++、Semantic highlighting等新特性，<br>CLion 是一款由JetBrains出品的强大的C/C++开发工具，支持Windows、Mac、Linux平台，是现代的智能集成开发工具，支持各种功能，如代码自动完成、提醒、版本控制工具等，支持C、C++、 C++11 等标准，非常的不错！</p>
<h3 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h3><h4 id="预处理指令-include"><a href="#预处理指令-include" class="headerlink" title="预处理指令-#include"></a>预处理指令-<em>#include</em></h4><p><code>#include &lt;stdio.h&gt;</code>意思是引用<code>stdio.h</code>头文件，在编译器实际编译之前，查找到该文件后把其中的所有内容复制到当前文件内并删除当前语句。</p>
<p><code>#include &lt;xxx.h&gt;</code>用于标准库文件或系统提供的头文件，去保存系统标准头文件的位置查找头文件。</p>
<p><code>#include &quot;xxx.h&quot;</code>用于用户自定义的头文件，先从当前目录查找是否有指定名称的头文件，找不到的话，再从标准文件目录中查找。</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p><img src="http://7sbl4z.com1.z0.glb.clouddn.com/blog/master/images/c_basic_type.jpg?imageMogr2/thumbnail/550x" alt=""></p>
<p>因为C语言不同类型变量的大小，是随着操作系统变化而变化的，所以使用 <code>sizeof(type)</code>方法得到对象或类型的存储字节大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBasicType</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//字符类型 char</span></div><div class="line">    <span class="keyword">char</span> c = <span class="string">'c'</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"c 的值：%c --&gt; char 所占字节：%d\n"</span>, c, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line">    <span class="comment">//c 的值：c --&gt; char 所占字节：1</span></div><div class="line"></div><div class="line">    <span class="comment">//短整形 short</span></div><div class="line">    <span class="keyword">short</span> sh = <span class="number">32</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sh 的值：%d --&gt; short 所占字节：%d\n"</span>, sh, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));</div><div class="line">    <span class="comment">//sh 的值：32 --&gt; short 所占字节：2</span></div><div class="line"></div><div class="line">    <span class="comment">//整形 int</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">90</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 的值：%d --&gt; int 所占字节：%d\n"</span>, i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    <span class="comment">//i 的值：90 --&gt; int 所占字节：4</span></div><div class="line"></div><div class="line">    <span class="comment">//长整形 long</span></div><div class="line">    <span class="keyword">long</span> l = <span class="number">12312</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"l 的值：%ld --&gt; long 所占字节：%d\n"</span>, l, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</div><div class="line">    <span class="comment">//l 的值：12312 --&gt; long 所占字节：8</span></div><div class="line"></div><div class="line">    <span class="comment">//单精度浮点型 float</span></div><div class="line">    <span class="keyword">float</span> f = <span class="number">12.3</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"f 的值：%f --&gt; float 所占字节：%d\n"</span>, f, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</div><div class="line">    <span class="comment">//f 的值：12.300000 --&gt; float 所占字节：4</span></div><div class="line"></div><div class="line">    <span class="comment">//双精度浮点型 double</span></div><div class="line">    <span class="keyword">double</span> d = <span class="number">234.3433</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"d 的值：%lf --&gt; double 所占字节：%d\n"</span>, d, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</div><div class="line">    <span class="comment">//d 的值：234.343300 --&gt; double 所占字节：8</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, <span class="string">"World!"</span>);</div><div class="line">    <span class="comment">//Hello World!</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"无符号八进制：%o\n"</span>, <span class="number">023</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"有符号八进制：%#o\n"</span>, <span class="number">023</span>);</div><div class="line">    <span class="comment">//无符号八进制：23</span></div><div class="line">    <span class="comment">//有符号八进制：023</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"无符号十六进制：%x\n"</span>, <span class="number">0x23443</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"有符号十六进制：%#x\n"</span>, <span class="number">0x23443</span>);</div><div class="line">    <span class="comment">//无符号十六进制：23443</span></div><div class="line">    <span class="comment">//有符号十六进制：0x23443</span></div><div class="line"></div><div class="line">    <span class="comment">//关于printf()中的输出占位符：%c、%d等，其中%为输出格式描述符。</span></div><div class="line"></div><div class="line">    <span class="comment">//char --&gt; %c</span></div><div class="line">    <span class="comment">//short、int --&gt; %d ：d为digital（数字）</span></div><div class="line">    <span class="comment">//long --&gt; %ld</span></div><div class="line">    <span class="comment">//float --&gt; %f</span></div><div class="line">    <span class="comment">//double --&gt; %lf</span></div><div class="line"></div><div class="line">    <span class="comment">//字符串 --&gt; %s</span></div><div class="line">    <span class="comment">//无符号八进制 --&gt; %o</span></div><div class="line">    <span class="comment">//有符号八进制 --&gt; %#o</span></div><div class="line">    <span class="comment">//无符号十六进制 --&gt; %x</span></div><div class="line">    <span class="comment">//有符号十六进制 --&gt; %#x</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h4><p>C语言中最重要的就是指针了，指针就是为了操作内存而生的。如同Java是对象的世界一样，C语言就是指针的世界。</p>
<blockquote>
<p>指针也是变量，它存储的是变量的内存地址，也只能存储内存地址，直接赋值也会被转化成内存地址，它的强大之处就在于，它能通过内存地址去操作对应内存地址的内容。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPointer</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = <span class="number">50</span>;<span class="comment">//定义变量 i=50</span></div><div class="line">    <span class="keyword">int</span> *p;<span class="comment">//声明 int 类型的指针变量 p，指针也是变量</span></div><div class="line">    p = &amp;i;<span class="comment">//在指针变量 p 中存储 i 的地址，&amp;i 是取变量 i 的地址</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 的地址：%#x\n"</span>, &amp;i);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 的地址：%#x\n"</span>, p);<span class="comment">//p 变量中存的是 i 的地址</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"p 的地址：%#x\n"</span>, &amp;p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 的值：%d\n"</span>, *p);<span class="comment">//用一元运算符 * 来返回 p 变量存的地址的变量的值，即 i 的值</span></div><div class="line">    <span class="comment">//i 的地址：0x55d1674c</span></div><div class="line">    <span class="comment">//i 的地址：0x55d1674c</span></div><div class="line">    <span class="comment">//p 的地址：0x5e5d2740</span></div><div class="line">    <span class="comment">//i 的值：50</span></div><div class="line"></div><div class="line">    <span class="comment">/*指针变量就是用来操作内存空间的*/</span></div><div class="line">    *p = <span class="number">20</span>;<span class="comment">//通过 *p 我们操作 i 变量，给 i 变量赋值20</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 的值变成了：%d\n"</span>, *p);</div><div class="line">    <span class="comment">//i 的值变成了：20</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="指针内存分析"><a href="#指针内存分析" class="headerlink" title="指针内存分析"></a>指针内存分析</h4><p><img src="http://7sbl4z.com1.z0.glb.clouddn.com/blog/master/images/c_pointer_memory.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*指针变量也是变量，所以指针也是可以运算的*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPointerVariable</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">75</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">80</span>&#125;;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"数组的地址：%#x\n"</span>, &amp;arr);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"这样得到数组的地址：%#x\n"</span>, arr);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"第一个元素的地址：%#x\n"</span>, &amp;arr[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"数组的值：%d\n"</span>, arr);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"第一个元素的值：%d\n"</span>, *arr);</div><div class="line">    <span class="comment">//数组的地址：0x55b89730</span></div><div class="line">    <span class="comment">//这样得到数组的地址：0x55b89730</span></div><div class="line">    <span class="comment">//第一个元素的地址：0x55b89730</span></div><div class="line">    <span class="comment">//数组的值：1438160688</span></div><div class="line">    <span class="comment">//第一个元素的值：75</span></div><div class="line"></div><div class="line">    <span class="comment">/*0x55b89730 转为十进制为 1438160688，且*arr返回的是第一个元素的值，*/</span></div><div class="line">    <span class="comment">/*所以数组类型的变量，存储就是首个元素的地址*/</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"=============\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"索引方式取数组元素：%d\n"</span>, arr[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"=============\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> *pInt = arr;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"指针方式取数组元素：%d\n"</span>, *pInt);</div><div class="line">        pInt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//索引方式取数组元素：75</span></div><div class="line">    <span class="comment">//索引方式取数组元素：40</span></div><div class="line">    <span class="comment">//索引方式取数组元素：25</span></div><div class="line">    <span class="comment">//索引方式取数组元素：80</span></div><div class="line">    <span class="comment">//=============</span></div><div class="line">    <span class="comment">//指针方式取数组元素：75</span></div><div class="line">    <span class="comment">//指针方式取数组元素：40</span></div><div class="line">    <span class="comment">//指针方式取数组元素：25</span></div><div class="line">    <span class="comment">//指针方式取数组元素：80</span></div><div class="line"></div><div class="line">    <span class="comment">/*通过指针变量 pInt 自增的方式，打印出了数组各元素的值，不难发现数组是*/</span></div><div class="line">    <span class="comment">/*用一段连续的内存空间存储数据，我们可以用同类型的指针，通过运算来直接操作内存*/</span></div><div class="line">    <span class="comment">/*注意：指针类型需要跟数组类型一致，在CLion编辑器下，两类型不一致时会报错，如：*/</span></div><div class="line">    <span class="comment">/*incompatible pointer types 'float *' and 'int[4]'*/</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * C语言的函数定义和Java的函数定义类似，只是没有 public ，private 等这样的权限控制</div><div class="line"> *</div><div class="line"> * 返回值类型 函数名(参数类型 参数名称, ...)&#123;</div><div class="line"> *      函数体</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 通过传入指针类型可以在方法中修改参数原来的值</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeNumByPointer</span><span class="params">(<span class="keyword">int</span> *pInt)</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"形参 pInt 的地址：%#x\n"</span>, pInt);</div><div class="line">    *pInt = <span class="number">90</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 非指针类型的形参，会为 i 变量开辟新的内存空间，所以做不到修改参数原来的值</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeNum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"形参 i 的地址：%#x\n"</span>, &amp;i);</div><div class="line">    i = <span class="number">80</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testChangeNum</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 原来的值：%d\n"</span>, i);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 原来的地址：%#x\n"</span>, &amp;i);</div><div class="line">    <span class="comment">//i 原来的值：10</span></div><div class="line">    <span class="comment">//i 原来的地址：0x50f548fc</span></div><div class="line"></div><div class="line">    changeNumByPointer(&amp;i);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 现在的值：%d\n"</span>, i);</div><div class="line">    <span class="comment">//形参 pInt 的地址：0x50f548fc</span></div><div class="line">    <span class="comment">//i 现在的值：90</span></div><div class="line"></div><div class="line">    changeNum(i);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 现在的值：%d\n"</span>, i);</div><div class="line">    <span class="comment">//形参 i 的地址：0x50f548cc</span></div><div class="line">    <span class="comment">//i 现在的值：90</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="二级指针和多级指针的概念"><a href="#二级指针和多级指针的概念" class="headerlink" title="二级指针和多级指针的概念"></a>二级指针和多级指针的概念</h4><p>二级指针就是指针的指针，二级指针存储的是一级指针的内存地址。依次类推可以有三级、四级等等，统称为多级指针。</p>
<p><img src="http://7sbl4z.com1.z0.glb.clouddn.com/blog/master/images/c_secondary_pointer_memory.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSecondaryPointer</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">    <span class="keyword">int</span> *pInt = &amp;i;<span class="comment">//一级地址存 i 的地址</span></div><div class="line">    <span class="keyword">int</span> **pInt1 = &amp;pInt;<span class="comment">//二级地址存 pInt 的地址</span></div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i 的地址：%#x\n"</span>, &amp;i);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"pInt 的地址：%#x\n"</span>, &amp;pInt);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"用二级指针取 pInt 的地址：%#x\n"</span>, pInt1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"用二级指针取 i 的地址：%#x\n"</span>, *pInt1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"用二级指针取 i 的值：%d\n"</span>, **pInt1);</div><div class="line">    <span class="comment">//i 的地址：0x56d688fc</span></div><div class="line">    <span class="comment">//pInt 的地址：0x56d688f0</span></div><div class="line">    <span class="comment">//用二级指针取 pInt 的地址：0x56d688f0</span></div><div class="line">    <span class="comment">//用二级指针取 i 的地址：0x56d688fc</span></div><div class="line">    <span class="comment">//用二级指针取 i 的值：10</span></div><div class="line"></div><div class="line">    **pInt1 = <span class="number">20</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"用二级指针修改 i 的值：%d\n"</span>, i);</div><div class="line">    <span class="comment">//用二级指针修改 i 的值：20</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数指针的概念"><a href="#函数指针的概念" class="headerlink" title="函数指针的概念"></a>函数指针的概念</h4><p>我们定义的函数跟变量一样，会有一个内存地址，我们可以把这个地址赋值给<em>函数指针</em>，这样通过函数指针就可以调用相应的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">logcat</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"随便打印一下..\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFuncPointer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//函数指针定义：返回值类型 (函数指针)(函数参数) = 函数地址</span></div><div class="line">    <span class="keyword">void</span> (*pFunc)() = &amp;logcat;</div><div class="line"></div><div class="line">    pFunc();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"函数的地址：%#x\n"</span>, logcat);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"函数的地址：%#x\n"</span>, &amp;logcat);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"函数指针的值：%#x\n"</span>, pFunc);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"函数指针的地址：%#x\n"</span>, &amp;pFunc);</div><div class="line">    <span class="comment">//函数的地址：0xd5754c0</span></div><div class="line">    <span class="comment">//函数的地址：0xd5754c0</span></div><div class="line">    <span class="comment">//函数指针的值：0xd5754c0</span></div><div class="line">    <span class="comment">//函数指针的地址：0x5268b8f8</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了函数指针我们就可以将函数当作参数传入到其他函数中，这样就实现了其他高级语言里的<em>闭包</em>，看例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 - num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*接收 一个返回值为int类型，输入两个int类型参数的函数指针 和 两个int类型参数*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>(*pFunc)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>, <span class="keyword">int</span> num1, <span class="keyword">int</span> num2) </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = pFunc(num1, num2);</div><div class="line">    printf(<span class="string">"计算完成：%d\n"</span>, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFuncPointer1</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    calculate(&amp;add, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">    <span class="comment">//计算完成：5</span></div><div class="line">    calculate(&amp;minus, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">    <span class="comment">//计算完成：-1</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*通过函数指针实现方法回调*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>&#123;</div><div class="line">    printf(<span class="string">"网络请求回调：%s\n"</span>, msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">requestNet</span><span class="params">(<span class="keyword">char</span> *url, <span class="keyword">void</span>(*pCallBack)</span><span class="params">(<span class="keyword">char</span> *)</span>) </span>&#123;</div><div class="line">    printf(<span class="string">"请求url：%s\n"</span>, url);</div><div class="line">    sleep(<span class="number">2</span>);<span class="comment">//模拟网络耗时</span></div><div class="line">    <span class="keyword">char</span> *msg = <span class="string">"我是返回的数据"</span>;</div><div class="line">    pCallBack(msg);</div><div class="line"></div><div class="line">    <span class="comment">//请求url：www.baidu.com</span></div><div class="line">    <span class="comment">//网络请求回调：我是返回的数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFuncPointer2</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *url = <span class="string">"www.baidu.com"</span>;</div><div class="line">    requestNet(url, &amp;callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*字符数组*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCharArray</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> arr[<span class="number">15</span>] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">' '</span>, <span class="string">'d'</span>, <span class="string">'e'</span>&#125;;</div><div class="line">    printf(<span class="string">"字符数组：%s\n"</span>, arr);<span class="comment">//用 %s 占位符可将字符数组作为字符串打印出来</span></div><div class="line">    <span class="comment">//字符数组：ab de</span></div><div class="line"></div><div class="line">    arr[<span class="number">1</span>] = <span class="string">'Y'</span>;<span class="comment">//修改第二个元素</span></div><div class="line">    printf(<span class="string">"修改了第二个字符：%s\n"</span>, arr);</div><div class="line">    <span class="comment">//修改了第二个字符：aY de</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*字符指针*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCharPointer</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *s = <span class="string">"Hello World!"</span>;<span class="comment">//是一段连续的内存地址，不可修改</span></div><div class="line">    printf(<span class="string">"字符指针内存地址：%#x\n"</span>, s);<span class="comment">//返回的是首个字符 H 的内存地址</span></div><div class="line">    printf(<span class="string">"打印字符串：%s\n"</span>, s);</div><div class="line">    <span class="comment">//字符指针内存地址：0x7ce4c63</span></div><div class="line">    <span class="comment">//打印字符串：Hello World!</span></div><div class="line"></div><div class="line">    <span class="keyword">char</span> *t = s + <span class="number">4</span>;<span class="comment">//这样 t 就指向了首个 o 字符</span></div><div class="line">    printf(<span class="string">"o 字符的地址：%#x\n"</span>, t);</div><div class="line">    <span class="comment">//o 字符的地址：0x7ce4c67</span></div><div class="line"></div><div class="line">    <span class="comment">//截取字符串 llo World!</span></div><div class="line">    s += <span class="number">2</span>;<span class="comment">//s 指向了首个 l 字符</span></div><div class="line">    <span class="keyword">while</span> (*s) &#123;</div><div class="line">        printf(<span class="string">"%c"</span>, *s);</div><div class="line">        s++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//llo World!</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：1，字符指针与字符数组最大的区别在于，字符指针不可修改内容，字符数组可以修改。2，输出格式占位符 %s 是把对应的参数<em>作为内存地址</em>，然后将地址指向的字符输出，并依次将该地址递增输出字符，直到遇到空字符时认为字符串结束。</p>
</blockquote>
<p>接着再看几个字符操作的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*拼接字符串*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSpliceString</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//用来存储合并字符串的容器</span></div><div class="line">    <span class="keyword">char</span> arr[<span class="number">50</span>] = &#123;<span class="string">'='</span>, <span class="string">'='</span>&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *c1 = <span class="string">"abcd"</span>;</div><div class="line">    <span class="keyword">char</span> *c2 = <span class="string">"efg"</span>;</div><div class="line"></div><div class="line">    strcat(arr, c1);<span class="comment">//将 c1 拼接到 arr ，不会清除原来的数据</span></div><div class="line">    strcat(arr, c2);</div><div class="line">    printf(<span class="string">"拼接结果：%s\n"</span>, arr);</div><div class="line">    <span class="comment">//拼接结果：==abcdefg</span></div><div class="line"></div><div class="line">    strcpy(arr, c1);<span class="comment">//strcpy，将 c1 拼接到 arr ，会清除原来的数据</span></div><div class="line">    strcat(arr, c2);</div><div class="line">    printf(<span class="string">"拼接结果：%s\n"</span>, arr);</div><div class="line">    <span class="comment">//拼接结果：abcdefg</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*查找单个字符*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQueryChar</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *s = <span class="string">"abcdefg hijklmn;"</span>;</div><div class="line">    <span class="keyword">char</span> *p = strchr(s, <span class="string">'g'</span>);<span class="comment">//查找某个字符，返回该字符的指针</span></div><div class="line">    printf(<span class="string">"截取 g 字符往后的字符串：%s\n"</span>, p);</div><div class="line">    <span class="comment">//截取 g 字符往后的字符串：g hijklmn;</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p) &#123;<span class="comment">//p 存储的是 g 字符的内存地址</span></div><div class="line">        printf(<span class="string">"g 字符索引位置：%d\n"</span>, p - s);</div><div class="line">        <span class="comment">//g 字符索引位置：6</span></div><div class="line"></div><div class="line">        printf(<span class="string">"截取 g 字符往后的字符串："</span>);</div><div class="line">        <span class="keyword">while</span> (*p) &#123;<span class="comment">//用指针递增的方法打印 g 字符往后的字符串</span></div><div class="line">            printf(<span class="string">"%c"</span>, *p);</div><div class="line">            p++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//截取 g 字符往后的字符串：g hijklmn;</span></div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        printf(<span class="string">"没有找到 g 字符\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*查找字符串*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQueryString</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *s = <span class="string">"这是一个中abcdefg hijk文字符串！"</span>;</div><div class="line">    <span class="keyword">char</span> *k = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> *p = strstr(s, k);<span class="comment">//查找某个字符串，返回该字符串的指针（其实是该字符串的首字符 a 的指针）</span></div><div class="line">    printf(<span class="string">"截取 abc 字符串往后的字符串：%s\n"</span>, p);</div><div class="line">    <span class="comment">//截取 abc 字符串往后的字符串：abcdefg hijk文字符串！</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p) &#123;</div><div class="line">        printf(<span class="string">"abc 字符串索引位置：%d\n"</span>, p - s);</div><div class="line">        <span class="comment">//abc 字符串索引位置：15</span></div><div class="line"></div><div class="line">        printf(<span class="string">"打印 b 字符：%c\n"</span>, *++p);<span class="comment">//p+1就得到了 b 的内存地址</span></div><div class="line">        <span class="comment">//打印 b 字符：b</span></div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        printf(<span class="string">"没有找到 abc 字符串\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="放在后边"><a href="#放在后边" class="headerlink" title="放在后边"></a>放在后边</h3><p>如有疑问和建议欢迎留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[结合Retrofit2.0体验OkHttp+RxJava]]></title>
      <url>http://51erwa.com/2017/02/08/okhttp+rxjava-experience/</url>
      <content type="html"><![CDATA[<h3 id="放在前边"><a href="#放在前边" class="headerlink" title="放在前边"></a>放在前边</h3><blockquote>
<p>注：本篇是结合Retrofit2.0来使用RxJava、OkHttp的一些姿势，关于RxJava的基础知识请先行补充。</p>
</blockquote>
<p><a href="https://github.com/drawf/demo.retrofit" target="_blank" rel="external">demo.retrofit传送门</a></p>
<p><img src="http://7sbl4z.com1.z0.glb.clouddn.com/demo.retrofit/blog/master/images/screenshot_2.png?imageMogr2/thumbnail/250x" alt=""></p>
<h3 id="OkHttp相关"><a href="#OkHttp相关" class="headerlink" title="OkHttp相关"></a>OkHttp相关</h3><h4 id="Interceptors概述"><a href="#Interceptors概述" class="headerlink" title="Interceptors概述"></a>Interceptors概述</h4><p>Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls.</p>
<p>拦截器是一种强大的机制，可以监视、重写和重试请求.</p>
<p>拦截器分两种：</p>
<ol>
<li>Application Interceptors 应用拦截器，通过 OkHttpClient.Builder() 调用 addInterceptor() 方法来注册。</li>
<li>NetWork Interceptors 网络拦截器，通过 OkHttpClient.Builder() 调用 addNetWorkInterceptor() 方法来注册。</li>
</ol>
<p>通过一张图看一下二者的区别：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1504154-8daf5fd9540545d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt=""></p>
<p>应用拦截器只关注程序从发出请求到拿到结果，而不关心网络底层是从缓存取的结果还是从一次真正的网络请求拿到的结果。</p>
<p>网络拦截器只关注每一次真正的网络请求。</p>
<p>所以，当一次请求发生一次重定向时，应用拦截器执行一次，网络拦截器会执行两次；当一次请求读的缓存时，应用拦截器执行一次，网络拦截器并不会执行。</p>
<h4 id="自定义LoggingInterceptor"><a href="#自定义LoggingInterceptor" class="headerlink" title="自定义LoggingInterceptor"></a>自定义LoggingInterceptor</h4><p><a href="https://github.com/drawf/demo.retrofit/blob/master/app/src/main/java/tv/wanzi/demo/retrofit/interceptor/LoggingInterceptor.java" target="_blank" rel="external">LoggingInterceptor传送门</a></p>
<p>首先看<code>Interceptor</code>接口，覆写<code>intercept</code>方法，拦截的核心代码都在该方法中写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/*需要覆写的拦截方法，具体操作都在该方法中进行*/</span></div><div class="line">    <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*通过Chain实例，可以得到Request实例，并可以通过proceed方法得到Response实例*/</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</div><div class="line">        <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">/*该方法每次调用都是进行一次网络请求（可能是取的缓存可能是真实网络请求），所以调用一次即可，切勿盲目多次调用*/</span></div><div class="line">        <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">        <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看一下<code>LoggingInterceptor</code>的核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">/*得到原来的Request实例后就可以 重写请求*/</span></div><div class="line">    Request originRequest = chain.request();</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">    <span class="comment">/*得到原来的Response实例后就可以 重写响应*/</span></div><div class="line">    Response originResponse = chain.proceed(originRequest);</div><div class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (BuildConfig.DEBUG &amp;&amp; eLog != LOG.NONE) &#123;</div><div class="line">        <span class="keyword">double</span> time = (t2 - t1) / <span class="number">1e6</span>d;</div><div class="line"></div><div class="line">        <span class="comment">//url ⇢ http://xxx</span></div><div class="line">        <span class="keyword">if</span> (eLog == LOG.DEFAULT) &#123;</div><div class="line">            String format = <span class="string">"method%s%s\nurl%s%s\nbody%s%s\ntime%s%s\n"</span> +</div><div class="line">                    <span class="string">"response code%s%s\nresponse body%s%s\n"</span>;</div><div class="line"></div><div class="line">            String message = String.format(format,</div><div class="line">                    SEPARATOR, originRequest.method(),</div><div class="line">                    SEPARATOR, originRequest.url(),</div><div class="line">                    SEPARATOR, requestBody2String(originRequest.body()),</div><div class="line">                    SEPARATOR, time,</div><div class="line">                    SEPARATOR, originResponse.code(),</div><div class="line">                   <span class="comment">/*这里需要注意的是originResponse.body()一旦消费掉后，响应体就会为空，解决方法见responseBody2String源码*/</span></div><div class="line">                    SEPARATOR, responseBody2String(originResponse.body()));</div><div class="line">            LogUtils.v(message);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eLog == LOG.ALL) &#123;</div><div class="line">            String format = <span class="string">"method%s%s\nurl%s%s\nheaders%s%s\nbody%s%s\ntime%s%s\n"</span> +</div><div class="line">                    <span class="string">"response code%s%s\nresponse headers%s%s\nresponse body%s%s\n"</span>;</div><div class="line"></div><div class="line">            String message = String.format(format,</div><div class="line">                    SEPARATOR, originRequest.method(),</div><div class="line">                    SEPARATOR, originRequest.url(),</div><div class="line">                    SEPARATOR, originRequest.headers(),</div><div class="line">                    SEPARATOR, requestBody2String(originRequest.body()),</div><div class="line">                    SEPARATOR, time,</div><div class="line">                    SEPARATOR, originResponse.code(),</div><div class="line">                    SEPARATOR, originResponse.headers(),</div><div class="line">                    SEPARATOR, responseBody2String(originResponse.body()));</div><div class="line">            LogUtils.v(message);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> originResponse;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">responseBody2String</span><span class="params">(ResponseBody responseBody)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (responseBody == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"this request has no response body."</span>;</div><div class="line"></div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line"></div><div class="line">    BufferedSource source = responseBody.source();</div><div class="line">    source.request(Long.MAX_VALUE); <span class="comment">// Buffer the entire body.</span></div><div class="line">    Buffer buffer = source.buffer().clone();<span class="comment">//clone出响应体内容，这样就不会消费掉了</span></div><div class="line"></div><div class="line">    Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">    MediaType contentType = responseBody.contentType();</div><div class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</div><div class="line">        charset = contentType.charset(charset);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isPlaintext(buffer)) &#123;</div><div class="line">        sb.append(buffer.readString(charset));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        sb.append(responseBody.contentLength()).append(<span class="string">"-byte binary body omitted)"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="OkHttp缓存概述"><a href="#OkHttp缓存概述" class="headerlink" title="OkHttp缓存概述"></a>OkHttp缓存概述</h4><p>OkHttp是由Square发布的一个HTTP client，它支持高速缓存服务器响应的语义，即Header中的<code>Cache-control</code>，<code>only-if-cached</code>等标签。</p>
<p>OkHttp的缓存设计和浏览器的一样，缓存是自动完成的，完全由服务器的Header决定，是用来提升用户体验降低服务器负荷的。</p>
<h4 id="一点HTTP缓存基础知识"><a href="#一点HTTP缓存基础知识" class="headerlink" title="一点HTTP缓存基础知识"></a>一点HTTP缓存基础知识</h4><blockquote>
<p>注：图中的 ETag 和 Last-Modified 没有优先级。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/98641-4bd320d4e34af60a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p>
<ol>
<li><p><strong>Expires</strong></p>
<p> HTTP1.0使用的过期策略，它使用时间戳来标识缓存是否过期。这个方式缺陷很明显，客户端和服务端的时间不同步时，导致过期判断经常不准确。现在HTTP请求基本都使用HTTP1.1以上了，这个字段基本没用了。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Expires: Thu, <span class="number">12</span> Jan <span class="number">2017</span> <span class="number">11</span>:<span class="number">01</span>:<span class="number">33</span> GMT</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Cache-Control</strong></p>
<p> Cache-Control与Expires的作用一致，区别在于前者使用过期时间长度来标识是否过期，例如前者使用过期为30天，后者使用过期时间为2017年2月30日。因此使用Cache-Control能够较为准确的判断缓存是否过期，现在基本上都是使用这个参数。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*表示此次请求结果过期时长为60s*/</span></div><div class="line">Cache-control: max-age=<span class="number">60</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>条件GET请求(Conditional GET Requests)与304</strong></p>
<p> 如果缓存过期或者强制放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只发送条件get请求即可，如果缓存是有效的，则返回304 Not Modified，否则直接返回body。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">第一种方式：Last-Modified-Date</div><div class="line"></div><div class="line"><span class="comment">/*客户端第一次请求时服务器返回如下*/</span></div><div class="line">Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div><div class="line"></div><div class="line"><span class="comment">/*客户端再次请求时，通过发送如下，交给服务器进行判断，如果缓存可用便返回304*/</span></div><div class="line">If-Modified-Since: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</div><div class="line"></div><div class="line">第二种方式：ETag，ETag是对资源文件的一种摘要，客户端并不需要了解实现细节。</div><div class="line"></div><div class="line"><span class="comment">/*当客户端第一请求时，服务器返回如下*/</span></div><div class="line">ETag: <span class="string">"5694c7ef-24dc"</span></div><div class="line"></div><div class="line"><span class="comment">/*客户端再次请求时，通过发送如下，交给服务器进行判断，如果缓存可用便返回304*/</span></div><div class="line">If-None-Match:<span class="string">"5694c7ef-24dc"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="一点Android存储访问目录知识"><a href="#一点Android存储访问目录知识" class="headerlink" title="一点Android存储访问目录知识"></a>一点Android存储访问目录知识</h4><ol>
<li><p><strong>应用数据目录（$appDataDir）</strong></p>
<p> 内部存储：$appDataDir = $rootDir/data/$packageName</p>
<p> 外部存储：$appDataDir = $rootDir/Android/data/$packageName</p>
<p> app卸载之后，这两个目录下的数据会被系统删除，我们应将应用的数据放在这两个目录下。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*使用 外部存储 需要的权限，从API 19/Andorid 4.4/KITKAT开始，不再需要显式声明这两个权限，除非要读写其他应用的应用数据($appDataDir)*/</span></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>应用数据目录下的-<em>缓存目录</em></strong></p>
<p> 内部存储：Context.getCacheDir()，机身内存不足时，文件就会被删除。</p>
<p> 外部存储：Context.getExternalCacheDir()，外部存储没有实时监控，空间不足时，文件不会被实时删除，可能返回空对象。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Context.getCacheDir()</div><div class="line">/data/data/tv.wanzi.demo.retrofit/cache</div><div class="line"></div><div class="line">Context.getExternalCacheDir():</div><div class="line">/storage/sdcard0/Android/data/tv.wanzi.demo.retrofit/cache</div></pre></td></tr></table></figure>
</li>
<li><p><strong>应用数据目录下的-<em>文件目录</em></strong></p>
<p> 内部存储：Context.getFilesDir()，Context.getFileStreamPath(String name) 返回以 name 为文件名的文件对象，name 为空时返回 $filesDir 本身。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Context.getFilesDir()</div><div class="line">/data/data/tv.wanzi.demo.retrofit/files</div><div class="line"></div><div class="line">Context.getFileStreamPath(<span class="string">""</span>)</div><div class="line">/data/data/tv.wanzi.demo.retrofit/files</div><div class="line"></div><div class="line">Context.getFileStreamPath(<span class="string">"file1"</span>):</div><div class="line">/data/data/tv.wanzi.demo.retrofit/files/file1</div></pre></td></tr></table></figure>
<p> 外部存储：Context.getExternalFilesDir(String type)，type 为空时返回 $filesDir 本身。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*type 系统指定了几种*/</span></div><div class="line">Environment.DIRECTORY_MUSIC</div><div class="line">Environment.DIRECTORY_PICTURES</div><div class="line">Environment.DIRECTORY_MOVIES</div><div class="line">Environment.DIRECTORY_DOWNLOADS</div><div class="line">...</div><div class="line"></div><div class="line">Context.getExternalFilesDir()</div><div class="line">/storage/sdcard0/Android/data/tv.wanzi.demo.retrofit/files</div><div class="line"></div><div class="line">Context.getExternalFilesDir(Environment.DIRECTORY_MUSIC)</div><div class="line">/storage/sdcard0/Android/data/tv.wanzi.demo.retrofit/files/Music</div><div class="line"></div><div class="line">Context.getExternalFilesDir(<span class="string">"responses"</span>)</div><div class="line">/storage/sdcard0/Android/data/tv.wanzi.demo.retrofit/files/responses</div></pre></td></tr></table></figure>
</li>
<li><p><strong>$cacheDir/$filesDir的安全性</strong></p>
<p> 内部存储：$cacheDir，$filesDir是app安全的，其他应用无法读取本应用的数据。</p>
<p> 外部存储：这两个文件夹其他应用程序也可访问，$filesDir中的媒体文件，不会被当做媒体扫描出来，加到媒体库中。</p>
</li>
</ol>
<h4 id="使用OkHttp的缓存功能"><a href="#使用OkHttp的缓存功能" class="headerlink" title="使用OkHttp的缓存功能"></a>使用OkHttp的缓存功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line"><span class="comment">/*配置好缓存即可使用缓存功能*/</span></div><div class="line">.cache(FileUtils.getOkHttpCache())</div><div class="line">.build();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cache <span class="title">getOkHttpCache</span><span class="params">()</span> </span>&#123;</div><div class="line">    File responses = getEFDDir(<span class="string">"responses"</span>);</div><div class="line">    <span class="keyword">if</span> (responses == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/*配置缓存目录及缓存大小*/</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cache(responses, HTTP_RESPONSE_DISK_CACHE_MAX_SIZE);<span class="comment">//10 * 1024 * 1024=10M</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*获取外部存储目录*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getEFDDir</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!hasSDCardMounted()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    Context context = MainApplication.getContext();</div><div class="line">    <span class="keyword">return</span> context.getExternalFilesDir(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RxJava相关"><a href="#RxJava相关" class="headerlink" title="RxJava相关"></a>RxJava相关</h3><h4 id="Retrofit2-0-RxJava的基本使用"><a href="#Retrofit2-0-RxJava的基本使用" class="headerlink" title="Retrofit2.0+RxJava的基本使用"></a>Retrofit2.0+RxJava的基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*gradle 加上这两个依赖*/</span></div><div class="line">compile <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.1.0'</span></div><div class="line">compile <span class="string">'io.reactivex:rxandroid:1.2.1'</span></div><div class="line"></div><div class="line"><span class="comment">/*构建Retrofit时加上RxJavaCallAdapterFactory*/</span></div><div class="line"><span class="keyword">new</span> Retrofit.Builder().addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line"></div><div class="line"><span class="comment">/*定义API时候就可以返回Observable类型了*/</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line"><span class="function">Observable&lt;JsonObject&gt; <span class="title">testRxJava</span><span class="params">(@Query(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*一次基本的请求过程*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRxJava</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable&lt;JsonObject&gt; observable = mMovieService.testRxJava(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">    observable</div><div class="line">            <span class="comment">//指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程，或者叫事件产生的线程。</span></div><div class="line">            .subscribeOn(Schedulers.io())</div><div class="line">            <span class="comment">//指定Subscriber所运行在的线程，或者叫事件消费的线程。</span></div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">new</span> Subscriber&lt;JsonObject&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;<span class="comment">//事件还未发送之前被调用，做一些准备工作</span></div><div class="line">                    <span class="keyword">super</span>.onStart();</div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava:RxJava Request onStart"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;<span class="comment">//事件队列完结</span></div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava:RxJava Request onCompleted"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;<span class="comment">//事件队列异常</span></div><div class="line">                    LogUtils.e(e);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(JsonObject jsonObject)</span> </span>&#123;<span class="comment">//处理返回数据</span></div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava:"</span> + jsonObject.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RxJava的Schedulers"><a href="#RxJava的Schedulers" class="headerlink" title="RxJava的Schedulers"></a>RxJava的Schedulers</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*在main线程中测试一下*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRxJavaScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable&lt;JsonObject&gt; observable = mMovieService.testRxJava(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">    observable</div><div class="line">            <span class="comment">/*同Subscriber.onStart()一样是在 subscribe() 调用后而且在事件发送前执行，区别在于它可以指定线程*/</span></div><div class="line">            <span class="comment">/*默认情况下，doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。*/</span></div><div class="line">            .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava Scheduler: doOnSubscribe thread name -&gt; "</span> + Thread.currentThread().getName());</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .subscribeOn(Schedulers.io())<span class="comment">//指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程，或者叫事件产生的线程。</span></div><div class="line">            .observeOn(AndroidSchedulers.mainThread())<span class="comment">//指定Subscriber所运行在的线程，或者叫事件消费的线程。</span></div><div class="line">            .subscribe(<span class="keyword">new</span> Subscriber&lt;JsonObject&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;<span class="comment">//这里onStart()总是在执行subscribe()方法的线程中执行，不能单独指定线程</span></div><div class="line">                    <span class="keyword">super</span>.onStart();</div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava Scheduler: onStart thread name -&gt; "</span> + Thread.currentThread().getName());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava Scheduler: onCompleted thread name -&gt; "</span> + Thread.currentThread().getName());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                    LogUtils.e(e);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(JsonObject jsonObject)</span> </span>&#123;</div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava Scheduler:"</span> + jsonObject.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*在新线程中测试一下*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRxJavaSchedulerInNewThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.run();</div><div class="line">            LogUtils.i(<span class="string">"Test RxJava Scheduler: request thread name -&gt; "</span> + Thread.currentThread().getName());</div><div class="line">            <span class="comment">//将请求代码发到这里，onStart 执行所在线程就不是主线程了，因为onStart()总是在执行subscribe()方法的线程中执行，不能单独指定线程</span></div><div class="line">            testRxJavaScheduler();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RxJava的Zip函数"><a href="#RxJava的Zip函数" class="headerlink" title="RxJava的Zip函数"></a>RxJava的Zip函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*新增一条返回JsonArray的API，以示区别*/</span></div><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="function">Observable&lt;JsonArray&gt; <span class="title">testRxJava1</span><span class="params">(@Url String url, @Query(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRxJavaZip</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable&lt;JsonObject&gt; observable = mMovieService.testRxJava(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">    Observable&lt;JsonArray&gt; observable1 = mMovieService.testRxJava1(<span class="string">"https://movie.douban.com/j/cinemas/?city_id=108288&amp;limit=5"</span>, <span class="number">0</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="comment">//zip方法把多个Observable组合成新的Observable，新的Observable对应的数据由call方法决定，它可以对数据源做二次操作</span></div><div class="line">    <span class="comment">//zip还有接受更多参数的重载方法</span></div><div class="line">    Observable.zip(observable, observable1, <span class="keyword">new</span> Func2&lt;JsonObject, JsonArray, JsonArray&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> JsonArray <span class="title">call</span><span class="params">(JsonObject jsonObject, JsonArray jsonElements)</span> </span>&#123;</div><div class="line">            JsonArray array = <span class="keyword">new</span> JsonArray();</div><div class="line">            array.add(jsonObject);</div><div class="line">            array.add(<span class="string">"================="</span>);</div><div class="line">            array.add(jsonElements);</div><div class="line">            <span class="keyword">return</span> array;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">            .subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;JsonArray&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(JsonArray jsonElements)</span> </span>&#123;</div><div class="line">                    LogUtils.i(<span class="string">"Test RxJava zip:"</span> + jsonElements.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="RxJava的Merge函数"><a href="#RxJava的Merge函数" class="headerlink" title="RxJava的Merge函数"></a>RxJava的Merge函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRxJavaMerge</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable&lt;JsonObject&gt; observable = mMovieService.testRxJava(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line">    Observable&lt;JsonArray&gt; observable1 = mMovieService.testRxJava1(<span class="string">"https://movie.douban.com/j/cinemas/?city_id=108288&amp;limit=5"</span>, <span class="number">0</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="comment">//merge方法可以合并多个数据源，但数据会被依次发射出来</span></div><div class="line">    Observable.merge(observable, observable1)</div><div class="line">            .subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;Object&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> JsonObject) &#123;</div><div class="line">                        LogUtils.i(<span class="string">"Test RxJava Merge:observable result -&gt; "</span> + object.toString());</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> JsonArray) &#123;</div><div class="line">                        LogUtils.i(<span class="string">"Test RxJava Merge:observable1 result -&gt; "</span> + object.toString());</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        LogUtils.e(<span class="keyword">new</span> RuntimeException(<span class="string">"数据异常"</span>));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="放在后边"><a href="#放在后边" class="headerlink" title="放在后边"></a>放在后边</h3><p>如有疑问和建议欢迎留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[全面体验Retrofit2.0]]></title>
      <url>http://51erwa.com/2017/01/11/retrofit2-experience/</url>
      <content type="html"><![CDATA[<h3 id="放在前边"><a href="#放在前边" class="headerlink" title="放在前边"></a>放在前边</h3><blockquote>
<p>注：本篇是对Retrofit2.0的全面体验，并未涉及RxJava、OkHttp。</p>
</blockquote>
<p><a href="https://github.com/drawf/demo.retrofit" target="_blank" rel="external">demo.retrofit传送门</a></p>
<p><img src="http://7sbl4z.com1.z0.glb.clouddn.com/demo.retrofit/blog/master/images/screenshot_1.png?imageMogr2/thumbnail/250x" alt=""></p>
<h3 id="Retrofit2-0"><a href="#Retrofit2-0" class="headerlink" title="Retrofit2.0"></a>Retrofit2.0</h3><p>Slogan:A type-safe HTTP client for Android and Java.</p>
<p>Retrofit is a type-safe REST client for Android built by Square. The library provides a powerful framework for authenticating and interacting with APIs and sending network requests with OkHttp.</p>
<p>官方标语：一个用于Android和Java平台的类型安全的网络框架。</p>
<p>Retrofit是一个Square开发的类型安全的REST安卓客户端请求库。这个库为网络认证、API请求以及用OkHttp发送网络请求提供了强大的框架 。</p>
<h3 id="Gradle配置"><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> <span class="string">'com.google.guava:guava:20.0'</span></div><div class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:retrofit:2.1.0'</span></div><div class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span></div></pre></td></tr></table></figure>
<p>Google Guava库是一个非常优秀的包含很多Java工具类集的库，广泛使用在Google公司内部，因此它可以被使用到几乎所有的Java项目中。更多使用姿势，大家自行google，未来我也会整理出关于Guava的博客。</p>
<h3 id="代码实践与记录"><a href="#代码实践与记录" class="headerlink" title="代码实践与记录"></a>代码实践与记录</h3><h4 id="同步和异步请求"><a href="#同步和异步请求" class="headerlink" title="同步和异步请求"></a>同步和异步请求</h4><blockquote>
<p>一个完整的请求包含以下几个步骤</p>
</blockquote>
<ol>
<li><p>构建Retrofit对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">         <span class="comment">//用于请求的HTTP client，设置OkHttpClient，有默认值。该方法是引用传递，对client的修改会影响后续请求。</span></div><div class="line">         .client(client)</div><div class="line">         .baseUrl(MovieService.BASE_URL)<span class="comment">//设置baseUrl</span></div><div class="line">         .addConverterFactory(GsonConverterFactory.create())</div><div class="line">         <span class="comment">//是否在调用create(Class)时检测接口定义是否正确，而不是在调用方法才检测，在开发、测试时使用。</span></div><div class="line">         .validateEagerly(BuildConfig.DEBUG)</div><div class="line">         .build();</div></pre></td></tr></table></figure>
</li>
<li><p>以interface的方式定义API</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MovieService</span> </span>&#123;</div><div class="line"></div><div class="line">    String BASE_URL = <span class="string">"https://api.douban.com/v2/movie/"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line">    <span class="function">Call&lt;JsonObject&gt; <span class="title">getTopMovie</span><span class="params">(@Query(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这里需要注意的是<code>BASE_URL</code>与<code>注解中的url</code>组合规则：</p>
 <figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BaseUrl ＋ 注解中的url ＝ 最终结果</div><div class="line"></div><div class="line">http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/v2/movie/ + top250 = http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/v2/movie/top250</div><div class="line">http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/v2/movie + top250 = http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/v2/top250</div><div class="line">http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/v2/movie/ + /top250 = http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/top250</div><div class="line">http<span class="variable">s:</span>//api.douban.<span class="keyword">com</span>/v2/movie/ + http<span class="variable">s:</span>//github.<span class="keyword">com</span>/drawf = http<span class="variable">s:</span>//github.<span class="keyword">com</span>/drawf</div></pre></td></tr></table></figure>
</li>
<li><p>得到Call对象即可进行请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">mMovieService = retrofit.create(MovieService.class);<span class="comment">//创建定义API接口的实现</span></div><div class="line">mCall = mMovieService.getTopMovie(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">//调用API得到Call对象</span></div><div class="line"></div><div class="line">mCall.cancel();<span class="comment">//取消请求，mCall执行方法只能调用一次,否则会抛IllegalStateException</span></div><div class="line">mCall.request();<span class="comment">//得到Request对象</span></div><div class="line">mCall.clone();<span class="comment">//克隆一个实例</span></div><div class="line">mCall.isCanceled();<span class="comment">//是否取消了请求</span></div><div class="line">mCall.isExecuted();<span class="comment">//是否已执行或已入队列</span></div><div class="line"></div><div class="line">mCall.execute();<span class="comment">//同步请求</span></div><div class="line">mCall.enqueue(Callback&lt;T&gt; callback);<span class="comment">//异步请求</span></div><div class="line"></div><div class="line"><span class="comment">//请求返回的Response对象</span></div><div class="line">response.code();<span class="comment">//HTTP status code.</span></div><div class="line">response.isSuccessful();<span class="comment">//Returns true if code() is in the range [200..300).</span></div><div class="line">response.message();<span class="comment">//HTTP status message or null if unknown.</span></div><div class="line">response.headers();<span class="comment">//HTTP headers.</span></div><div class="line"></div><div class="line">response.raw();<span class="comment">//The raw response from the HTTP client. 打印发现该方法返回数据不全</span></div><div class="line">response.body();<span class="comment">//The deserialized response body of a successful response.它就是你想要的数据</span></div><div class="line">response.errorBody();<span class="comment">//The raw response body of an unsuccessful response.</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="API的注解使用"><a href="#API的注解使用" class="headerlink" title="API的注解使用"></a>API的注解使用</h4><p>Retrofit注解共23个，分三类介绍</p>
<ol>
<li><p>HTTP请求方法</p>
 <table><thead><tr class="thead-first-child"><th align="center"> 注解 </th><th align="center"> 说明 </th></tr></thead><tbody><tr class="tbody-first-child"><td align="center"> GET、POST、PUT、DELETE、<br>PATCH、HEAD、OPTIONS </td><td align="center"> 1，分别对应HTTP请求方法<br> 2，接受一个字符串作为注解中的url，默认为&quot;&quot;</td></tr><tr class="tbody-even-child"><td align="center"> HTTP </td><td align="center"> 可以替换上述7个方法，或者其它扩展方法 </td></tr></tbody></table>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*可以替代其它请求方法*/</span></div><div class="line"><span class="comment">/*String method(); 请求方法，必须大写*/</span></div><div class="line"><span class="comment">/*String path() default ""; 请求路径*/</span></div><div class="line"><span class="comment">/*boolean hasBody() default false; 是否有请求体*/</span></div><div class="line"><span class="meta">@HTTP</span>(method = <span class="string">"GET"</span>, path = <span class="string">"top250"</span>, hasBody = <span class="keyword">false</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testHttp</span><span class="params">(@Query(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>参数类</p>
 <table><thead><tr class="thead-first-child"><th align="center"> 注解 </th><th align="center"> 说明 </th></tr></thead><tbody><tr class="tbody-first-child"><td align="center"> Query、QueryMap </td><td align="center"> 用于GET的请求参数 </td></tr><tr class="tbody-even-child"><td align="center"> Url </td><td align="center"> 用于全路径复写BaseUrl </td></tr><tr class="tbody-odd-child"><td align="center"> Path </td><td align="center"> 用于替换和动态更新URL的占位符 </td></tr><tr class="tbody-even-child"><td align="center"> Header、HeaderMap、Headers </td><td align="center"> 用于添加请求头 </td></tr><tr class="tbody-odd-child"><td align="center"> Body </td><td align="center"> 用于POST、PUT、PATCH请求体 </td></tr><tr class="tbody-even-child"><td align="center"> Field、FieldMap </td><td align="center"> 用于form表单形式的键值对参数 </td></tr><tr class="tbody-odd-child"><td align="center"> Part、PartMap </td><td align="center"> 用于POST文件上传 </td></tr></tbody></table>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*@Query，@QueryMap 查询参数，用于GET查询，两者都可以约定是否需要encode，默认false*/</span></div><div class="line"><span class="comment">/*@Query(value = "start", encoded = true) int start*/</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testQueryMap</span><span class="params">(@QueryMap(encoded = <span class="keyword">true</span>)</span> Map&lt;String, Object&gt; params)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*使用全路径复写baseUrl，用于非统一baseUrl的场景*/</span></div><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testUrl</span><span class="params">(@Url String url)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/*URL占位符，用于替换和动态更新，相应的参数必须使用相同的字符串被@Path进行注释*/</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"&#123;type&#125;"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testPath</span><span class="params">(@Path(<span class="string">"type"</span>)</span> String type, @<span class="title">Query</span><span class="params">(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*@Header，@HeaderMap，@Headers 不能被互相覆盖*/</span></div><div class="line"><span class="meta">@Headers</span>(&#123;</div><div class="line">        <span class="string">"token:test override"</span>,</div><div class="line">        <span class="string">"User-Agent: Wanzi-Retrofit-Sample-App"</span></div><div class="line">&#125;)</div><div class="line"><span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testHeader</span><span class="params">(@Header(<span class="string">"token"</span>)</span> String token, @<span class="title">Query</span><span class="params">(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*用于POST、PUT、PATCH请求体，将实例对象根据GsonConverterFactory定义的转化方式转换为对应的json字符串参数*/</span></div><div class="line"><span class="comment">/*@Body与@FormUrlEncoded、@Field不能同时使用*/</span></div><div class="line"><span class="meta">@PUT</span>(<span class="string">"update"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testBody</span><span class="params">(@Body User user)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/*@Field，@FieldMap 为form表单形式的键值对*/</span></div><div class="line"><span class="comment">/*需要添加@FormUrlEncoded表示表单提交 Content-Type:application/x-www-form-urlencoded*/</span></div><div class="line"><span class="meta">@FormUrlEncoded</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"update"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testField</span><span class="params">(@Field(<span class="string">"name"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*@Part，@PartMap 用于POST文件上传*/</span></div><div class="line"><span class="comment">/*其中@Part MultipartBody.Part代表文件，@Part("key") RequestBody或其它类型代表参数*/</span></div><div class="line"><span class="comment">/*需要添加@Multipart表示支持文件上传的表单，Content-Type: multipart/form-data*/</span></div><div class="line"><span class="meta">@Multipart</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"upload"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testPart</span><span class="params">(@Part(<span class="string">"desc"</span>)</span> String desc, @Part MultipartBody.Part file)</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>标记类</p>
 <table><thead><tr class="thead-first-child"><th align="center"> 注解 </th><th align="center"> 说明 </th></tr></thead><tbody><tr class="tbody-first-child"><td align="center"> FormUrlEncoded </td><td align="center"> 表示请求体是一个Form表单 </td></tr><tr class="tbody-even-child"><td align="center"> Multipart </td><td align="center"> 1，意思为多部分，表示请求体是一个支持文件上传的Form表单<br> 2，建议去深入了解HTTP协议</td></tr><tr class="tbody-odd-child"><td align="center"> Streaming </td><td align="center"> 表示响应体数据以流的形式返回 </td></tr></tbody></table>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*@Field，@FieldMap 为form表单形式的键值对*/</span></div><div class="line"><span class="comment">/*需要添加@FormUrlEncoded表示表单提交 Content-Type:application/x-www-form-urlencoded*/</span></div><div class="line"><span class="meta">@FormUrlEncoded</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"update"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testField</span><span class="params">(@Field(<span class="string">"name"</span>)</span> String name, @<span class="title">Field</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*@Part，@PartMap 用于POST文件上传*/</span></div><div class="line"><span class="comment">/*其中@Part MultipartBody.Part代表文件，@Part("key") RequestBody或其它类型代表参数*/</span></div><div class="line"><span class="comment">/*需要添加@Multipart表示支持文件上传的表单，Content-Type: multipart/form-data*/</span></div><div class="line"><span class="meta">@Multipart</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"upload"</span>)</div><div class="line"><span class="function">Call&lt;JsonObject&gt; <span class="title">testPart</span><span class="params">(@Part(<span class="string">"desc"</span>)</span> String desc, @Part MultipartBody.Part file)</span>;</div><div class="line"></div><div class="line"><span class="comment">/*用于下载文件*/</span></div><div class="line"><span class="comment">/*表示响应体数据以流的形式返回，如果没有使用该注解，默认会把数据全部载入内存，之后是从内存中读取数据，所以数据很大时，适合用该标记*/</span></div><div class="line"><span class="meta">@Streaming</span></div><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">testStreaming</span><span class="params">(@Url String url)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="指定返回类型Map、List"><a href="#指定返回类型Map、List" class="headerlink" title="指定返回类型Map、List"></a>指定返回类型Map、List</h4><p>GsonConverterFactory支持返回类型Map、List，实验发现不支持String。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line">Call&lt;Map&lt;String, Object&gt;&gt; testMap(<span class="meta">@Query</span>(<span class="string">"start"</span>) <span class="keyword">int</span> start, <span class="meta">@Query</span>(<span class="string">"count"</span>) <span class="keyword">int</span> count);</div><div class="line"></div><div class="line"><span class="meta">@GET</span></div><div class="line">Call&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; testList(<span class="meta">@Url</span> String url, <span class="meta">@Query</span>(<span class="string">"start"</span>) <span class="keyword">int</span> start, <span class="meta">@Query</span>(<span class="string">"count"</span>) <span class="keyword">int</span> count);</div></pre></td></tr></table></figure>
<h4 id="自定义Converter、CallAdapter"><a href="#自定义Converter、CallAdapter" class="headerlink" title="自定义Converter、CallAdapter"></a>自定义Converter、CallAdapter</h4><h5 id="自定义StringConverter"><a href="#自定义StringConverter" class="headerlink" title="自定义StringConverter"></a>自定义StringConverter</h5><p><code>Converter</code>的目的是将<code>Call&lt;ResponseBody&gt;</code>转换为<code>Call&lt;JsonObject&gt;</code>、<code>Call&lt;Map&lt;String, Object&gt;&gt;</code>、<code>Call&lt;String&gt;</code>等等。</p>
<ol>
<li><p><code>new Retrofit.Builder().addConverterFactory(Converter.Factory factory)</code>，该方法接收一个Factory，该工厂向Retrofit提供相应的Converter，<br>所以第一步写一个工厂类。具体写的时候多参考<code>GsonConverterFactory</code>源码，有助于理解。</p>
<p> 抽象类<code>Converter.Factory</code>中有三个可以覆写的方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个将ResponseBody响应体转换为自定义类型的Converter，不能处理时应返回null*/</span></div><div class="line"><span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</div><div class="line">    Retrofit retrofit) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*创建一个将自定义类型转换为RequestBody请求体的Converter，不能处理时应返回null*/</span></div><div class="line"><span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</div><div class="line">    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*这里用于对Field、FieldMap、Header、HeaderMap、Path、Query、QueryMap注解的处理，Retrofit默认调用的toString方法*/</span></div><div class="line"><span class="keyword">public</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</div><div class="line">    Retrofit retrofit) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 因为我们只要将请求结果<code>ResponseBody</code>转换为<code>String</code>，所以只覆写<code>responseBodyConverter</code>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringConverterFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        <span class="keyword">if</span> (type == String.class) &#123;<span class="comment">//判断是否是要处理的类型</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StringResponseBodyConverter();<span class="comment">//这里创建具体的Converter</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//不能处理就返回null</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>public interface Converter&lt;F, T&gt;</code>，该泛型接口提供了一个接口<code>T convert(F value) throws IOException;</code>实现这个接口，可以将F泛型转化为T泛型。</p>
<p> 我们想从<code>Call&lt;ResponseBody&gt;</code>转换为<code>Call&lt;String&gt;</code>，所以<code>F</code>、<code>T</code>分别对应<code>ResponseBody</code>、<code>String</code>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringResponseBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//    T convert(F value) throws IOException;</span></div><div class="line"><span class="comment">//    实现从 F(from) 到 T(to) 的转换</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> value.string();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            value.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>至此就可以愉快的使用自定义的<code>Converter</code>了.</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回类型定义为String</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line"><span class="function">Call&lt;String&gt; <span class="title">testStringConverter</span><span class="params">(@Query(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line"><span class="comment">//构建Retrofit时加上我们的StringConverterFactory</span></div><div class="line">.addConverterFactory(StringConverterFactory.create())<span class="comment">//两种Converter都支持的类型优先使用第一个</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="自定义CustomCallAdapter"><a href="#自定义CustomCallAdapter" class="headerlink" title="自定义CustomCallAdapter"></a>自定义CustomCallAdapter</h5><p><code>CallAdapter</code>的目的是将<code>Call&lt;?&gt;</code>转换为RxJava的<code>Observable&lt;?&gt;</code>、Guava的<code>ListenableFuture&lt;?&gt;</code>、自定义的<code>CustomCall&lt;?&gt;</code>，<br>这里就是体验下自定义CallAdapter，工作中用官方提供的就能满足需求。</p>
<ol>
<li><p><code>new Retrofit.Builder().addCallAdapterFactory(CallAdapter.Factory factory)</code>，该方法接收一个Factory，该工厂向Retrofit提供CallAdapter，<br>所以第一步写一个工厂类。具体写的时候多参考<code>RxJavaCallAdapterFactory</code>、<code>GuavaCallAdapterFactory</code>源码，有助于理解。</p>
<p> 抽象类<code>CallAdapter.Factory</code>中有一个抽象方法，两个工具方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个将Call&lt;?&gt;转换为自定义类型的CallAdapter，根据returnType判断是否能处理，不能处理时应返回null，此时的returnType为Call&lt;?&gt;类型*/</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit);</div><div class="line"></div><div class="line"><span class="comment">/*用于获取泛型的上边界参数，如Call&lt;?&gt;中的?、Call&lt;JsonObject&gt;中的JsonObject*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title">getParameterUpperBound</span><span class="params">(<span class="keyword">int</span> index, ParameterizedType type)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*用于获取泛型的原始类型，如Call&lt;?&gt;中的Call、Observable&lt;?&gt;中的Observable、CustomCall&lt;?&gt;中的CustomCall*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</div><div class="line">  <span class="keyword">return</span> Utils.getRawType(type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 所以可以写出工厂类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomCallAdapterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomCallAdapterFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*在本例中*/</span></div><div class="line">    <span class="comment">/*returnType为CustomCall&lt;R&gt;*/</span></div><div class="line">    <span class="comment">/*getRawType(returnType)为CustomCall.class*/</span></div><div class="line">    <span class="comment">/*responseType为R的具体类型*/</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        <span class="keyword">if</span> (getRawType(returnType) != CustomCall.class) &#123;<span class="comment">//检查返回的原始类型是否为CustomCall</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;"</span>);</div><div class="line">        &#125;</div><div class="line">        Type responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomCallAdapter(responseType);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>public interface CallAdapter&lt;T&gt;</code>，该泛型接口中提供了两个接口。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*用于Converter的返回类型，如CustomCall&lt;String&gt;中的String*/</span></div><div class="line"><span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/*将Call&lt;?&gt;类型转换为T类型，如CustomCall&lt;?&gt;*/</span></div><div class="line">&lt;R&gt; <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</div></pre></td></tr></table></figure>
<p> 所以可以写出具体的<code>CustomCallAdapter</code>类。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*自定义的Call适配器，作用为将返回的Call&lt;R&gt; 转化为 CustomCall&lt;R&gt;*/</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCallAdapter</span> <span class="keyword">implements</span> <span class="title">CallAdapter</span>&lt;<span class="title">CustomCall</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Type responseType;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCallAdapter</span><span class="params">(Type responseType)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.responseType = responseType;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.responseType;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;R&gt; <span class="function">CustomCall&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomCall(call);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后需要定义出<code>CustomCall&lt;R&gt;</code>，这里的<code>CustomCall</code>是对<code>Call</code>的一个简单包装，提供一个<code>getResult()</code>方法获取请求响应体。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCall</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Call&lt;R&gt; call;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCall</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.call = call;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 同步请求返回结果</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.call.execute().body();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>大功告成，上手试试吧，<code>String</code>可以换成<code>JsonObject</code>等等。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*返回类型定义为CustomCall*/</span></div><div class="line"><span class="meta">@GET</span>(<span class="string">"top250"</span>)</div><div class="line">CustomCallAdapterFactory.<span class="function">CustomCall&lt;String&gt; <span class="title">testCustomCallAdapter</span><span class="params">(@Query(<span class="string">"start"</span>)</span> <span class="keyword">int</span> start, @<span class="title">Query</span><span class="params">(<span class="string">"count"</span>)</span> <span class="keyword">int</span> count)</span>;</div><div class="line"></div><div class="line"><span class="comment">//构建Retrofit时加上我们的StringConverterFactory</span></div><div class="line">.addCallAdapterFactory(CustomCallAdapterFactory.create())<span class="comment">//设置自定义请求适配器</span></div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">customCallAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> CustomCallAdapterFactory.CustomCall&lt;String&gt; customCall = mMovieService.testCustomCallAdapter(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                String result = customCall.getResult();</div><div class="line">                LogUtils.i(<span class="string">"CustomCallAdapter："</span> + result);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LogUtils.e(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="放在后边"><a href="#放在后边" class="headerlink" title="放在后边"></a>放在后边</h3><p>关于Retrofit2.0的姿势就写到这里了，如有疑问和建议欢迎留言。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[彻底理解什么是REST]]></title>
      <url>http://51erwa.com/2016/11/30/what-is-RESTful/</url>
      <content type="html"><![CDATA[<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>RESTful，是目前最为流行的一种互联网软件架构。因为它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。本小节我们将来学习它到底是一种什么样的架构？以及在Go里面如何来实现它。</p>
<h3 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h3><p>REST(REpresentational State Transfer)这个概念，<strong>译为“表现层状态转化”</strong>，首次出现是在 2000年Roy Thomas Fielding（他是HTTP规范的主要编写者之一）的博士论文中，它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful的。</p>
<p>要理解什么是REST，我们需要理解下面几个概念:</p>
<ul>
<li><p>资源（Resources）<br>REST是“表现层状态转化”，其实它省略了主语。“表现层”其实指的是“资源”的“表现层”。</p>
<p>那么什么是资源呢？就是我们平常上网访问的一张图片、一个文档、一个视频等。这些资源我们通过URI来定位，也就是一个URI表示一个资源。</p>
</li>
<li><p>表现层（Representation）</p>
<p>资源是做一个具体的实体信息，他可以有多种的展现方式。而把实体展现出来就是表现层，例如一个txt文本信息，他可以输出成html、json、xml等格式，一个图片他可以jpg、png等方式展现，这个就是表现层的意思。</p>
<p>URI确定一个资源，但是如何确定它的具体表现形式呢？应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对“表现层”的描述。</p>
</li>
<li><p>状态转化（State Transfer）</p>
<p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，肯定涉及到数据和状态的变化。而HTTP协议是无状态的，那么这些状态肯定保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，肯定要通过某种方式来通知它。</p>
<p>客户端能通知服务器端的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
</li>
</ul>
<p><strong>综合上面的解释，我们总结一下什么是RESTful架构：</strong></p>
<ul>
<li>（1）每一个URI代表一种资源；</li>
<li>（2）客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”。</li>
</ul>
<p>Web应用要满足REST最重要的原则是:客户端和服务器之间的交互在请求之间是无状态的,即从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外此请求可以由任何可用服务器回答，这十分适合云计算之类的环境。因为是无状态的，所以客户端可以缓存数据以改进性能。</p>
<p>另一个重要的REST原则是系统分层，这表示组件无法了解除了与它直接交互的层次以外的组件。通过将系统知识限制在单个层，可以限制整个系统的复杂性，从而促进了底层的独立性。</p>
<p>下图即是REST的架构图：</p>
<p><img src="https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/8.3.rest2.png?raw=true" alt=""></p>
<p>图8.5 REST架构图</p>
<p>当REST架构的约束条件作为一个整体应用时，将生成一个可以扩展到大量客户端的应用程序。它还降低了客户端和服务器之间的交互延迟。统一界面简化了整个系统架构，改进了子系统之间交互的可见性。REST简化了客户端和服务器的实现，而且对于使用REST开发的应用程序更加容易扩展。</p>
<p>下图展示了REST的扩展性：</p>
<p><img src="https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/8.3.rest.png?raw=true" alt=""></p>
<p>图8.6 REST的扩展性</p>
<h3 id="RESTful的实现"><a href="#RESTful的实现" class="headerlink" title="RESTful的实现"></a>RESTful的实现</h3><p>Go没有为REST提供直接支持，但是因为RESTful是基于HTTP协议实现的，所以我们可以利用<code>net/http</code>包来自己实现，当然需要针对REST做一些改造，REST是根据不同的method来处理相应的资源，目前已经存在的很多自称是REST的应用，其实并没有真正的实现REST，我暂且把这些应用根据实现的method分成几个级别，请看下图：</p>
<p><img src="https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/8.3.rest3.png?raw=true" alt=""></p>
<p>图8.7 REST的level分级</p>
<p>上图展示了我们目前实现REST的三个level，我们在应用开发的时候也不一定全部按照RESTful的规则全部实现他的方式，因为有些时候完全按照RESTful的方式未必是可行的，RESTful服务充分利用每一个HTTP方法，包括<code>DELETE</code>和<code>PUT</code>。可有时，HTTP客户端只能发出<code>GET</code>和<code>POST</code>请求：</p>
<ul>
<li><p>HTML标准只能通过链接和表单支持<code>GET</code>和<code>POST</code>。在没有Ajax支持的网页浏览器中不能发出<code>PUT</code>或<code>DELETE</code>命令</p>
</li>
<li><p>有些防火墙会挡住HTTP <code>PUT</code>和<code>DELETE</code>请求要绕过这个限制，客户端需要把实际的<code>PUT</code>和<code>DELETE</code>请求通过 POST 请求穿透过来。RESTful 服务则要负责在收到的 POST 请求中找到原始的 HTTP 方法并还原。</p>
</li>
</ul>
<p>我们现在可以通过<code>POST</code>里面增加隐藏字段<code>_method</code>这种方式可以来模拟<code>PUT</code>、<code>DELETE</code>等方式，但是服务器端需要做转换。我现在的项目里面就按照这种方式来做的REST接口。当然Go语言里面完全按照RESTful来实现是很容易的，我们通过下面的例子来说明如何实现RESTful的应用设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/drone/routes"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getuser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	params := r.URL.Query()</div><div class="line">	uid := params.Get(<span class="string">":uid"</span>)</div><div class="line">	fmt.Fprintf(w, <span class="string">"you are get user %s"</span>, uid)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyuser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	params := r.URL.Query()</div><div class="line">	uid := params.Get(<span class="string">":uid"</span>)</div><div class="line">	fmt.Fprintf(w, <span class="string">"you are modify user %s"</span>, uid)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteuser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	params := r.URL.Query()</div><div class="line">	uid := params.Get(<span class="string">":uid"</span>)</div><div class="line">	fmt.Fprintf(w, <span class="string">"you are delete user %s"</span>, uid)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">adduser</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	uid := r.FormValue(<span class="string">"uid"</span>)</div><div class="line">	fmt.Fprint(w, <span class="string">"you are add user %s"</span>, uid)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	mux := routes.New()</div><div class="line">	mux.Get(<span class="string">"/user/:uid"</span>, getuser)</div><div class="line">	mux.Post(<span class="string">"/user/"</span>, adduser)</div><div class="line">	mux.Del(<span class="string">"/user/:uid"</span>, deleteuser)</div><div class="line">	mux.Put(<span class="string">"/user/:uid"</span>, modifyuser)</div><div class="line">	http.Handle(<span class="string">"/"</span>, mux)</div><div class="line">	http.ListenAndServe(<span class="string">":8088"</span>, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码演示了如何编写一个REST的应用，我们访问的资源是用户，我们通过不同的method来访问不同的函数，这里使用了第三方库<code>github.com/drone/routes</code>，在前面章节我们介绍过如何实现自定义的路由器，这个库实现了自定义路由和方便的路由规则映射，通过它，我们可以很方便的实现REST的架构。通过上面的代码可知，REST就是根据不同的method访问同一个资源的时候实现不同的逻辑处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>REST是一种架构风格，汲取了WWW的成功经验：无状态，以资源为中心，充分利用HTTP协议和URI协议，提供统一的接口定义，使得它作为一种设计Web服务的方法而变得流行。在某种意义上，通过强调URI和HTTP等早期Internet标准，REST是对大型应用程序服务器时代之前的Web方式的回归。目前Go对于REST的支持还是很简单的，通过实现自定义的路由规则，我们就可以为不同的method实现不同的handle，这样就实现了REST的架构。</p>
<h3 id="原文摘自"><a href="#原文摘自" class="headerlink" title="原文摘自"></a>原文摘自</h3><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.3.md" target="_blank" rel="external">什么是REST-GitHub</a>讲解的非常详细</p>
<h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>以上边go的例子来讲，<strong>/user/</strong>表示用户这种资源即一个<strong>URI</strong>，使用<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>这四种HTTP方法配合<strong>uid</strong>这个参数，对同一个URI进行<strong>增删改查</strong>操作从而改变了用户这种资源表现出来的状态，如修改了某用户名字、删除了某个用户等。</p>
<p>再次理解下什么是RESTful架构：</p>
<ul>
<li>（1）每一个URI代表一种资源；</li>
<li>（2）客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转化”。</li>
</ul>
<p>所以符合这种<strong>约束</strong>来设计的API才算真正实现了RESTful架构，当然有时候我们也无需每个细节都要严格按照这些<strong>约束</strong>来做，比如文中提到“因为有些时候完全按照RESTful的方式未必是可行的”，所以由需求驱动，灵活应变，最终享受到了RESTful带来的<strong>结构清晰、易于理解、扩展方便</strong>的特性，那这就是最佳实践了！</p>
]]></content>
    </entry>
    
  
  
</search>
